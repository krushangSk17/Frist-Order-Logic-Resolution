# -*- coding: utf-8 -*-
"""Ai_homwork3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l3MNhZT21xPXg4HWCnjfYUEEFSjvJ97g
"""
import re
import time
pattern = r'(\w+)\((.*?)\)'

def compare_predicates(p1, p2):
    if(p1[0]=='~'):
        p1 = p1[1:]
    if(p2[0] == '~'):
        p2 = p2[1:]
    # Extract predicate name and arguments from each predicate string
    name1, args1 = re.match(pattern, p1).groups()
    name2, args2 = re.match(pattern, p2).groups()

    # Split argument strings into individual arguments
    args1 = args1.split(',')
    args2 = args2.split(',')

    if (len(args1) != len(args2)):
        return False

    for i in range(len(args1)):
        if (args1[i].islower() or args2[i].islower()):
            continue
        elif (args1[i] == args2[i]):
            continue
        else:
            return False

    return name1 == name2

def renameVariables(query1, query2):

    alphabets = 'abcdefghijklmnopqrstuvwxyz'
    alphabets = [char for char in alphabets][::-1]

    q1 = [query.strip() for query in query1.split('|')]
    q2 = [query.strip() for query in query2.split('|')]

    set1 = {}
    old1 = {}
    if (query1):

        for pred in q1:
            if (pred[0] == '~'):
                pred = pred[1:]
            name1, args1 = re.match(pattern, pred).groups()
            args1 = args1.split(',')
            for arg in args1:
                if (arg.islower() and arg not in old1):
                    old1[arg] = 1

        for pred in q1:

            if (pred[0] == '~'):
                pred = pred[1:]

            name1, args1 = re.match(pattern, pred).groups()
            args1 = args1.split(',')

            for arg in args1:
                if (arg.islower() and arg not in set1):
                    new = alphabets.pop()
                    while(new in old1):
                        new = alphabets.pop()
                    set1[arg] = new

        for i in set1:
            query1 = change_vars(query1, i, set1[i])

    set2 = {}
    old2 = {}
    if (query2):
        for pred in q2:
            if (pred[0] == '~'):
                pred = pred[1:]
            name2, args2 = re.match(pattern, pred).groups()
            args2 = args2.split(',')
            for arg in args2:
                if (arg.islower() and arg not in old2):
                    old1[arg] = 1

        for pred in q2:
            if (pred[0] == '~'):
                pred = pred[1:]

            name2, args2 = re.match(pattern, pred).groups()
            args2 = args2.split(',')

            for arg in args2:
                if (arg.islower() and arg not in set2):
                    new = alphabets.pop()
                    while (new in old2):
                        new = alphabets.pop()
                    set2[arg] = new

        for i in set2:
            query2 = change_vars(query2, i, set2[i])

    return (query1, query2)

def find_compatible(Query):
    pos = True
    position = []

    if (Query[0] == '~'):
        pos = False
        Query = Query[1:]

    for i in range(len(CNF_KB)):
        sen = CNF_KB[i]
        sen = sen.split('|')
        for j in range(len(sen)):
            pred = sen[j]
            pred = pred.strip()
            poscheck = True

            if (pred[0] == '~'):
                poscheck = False
                pred = pred[1:]

            if (poscheck != pos and compare_predicates(pred, Query)):
                position.append((i, j))

    return position

def sentence_compatible(sen):
    compatible = {}

    sen = sen.split('|')
    for i in range(len(sen)):
        QueryLocal = sen[i].strip()
        compatible[QueryLocal] = find_compatible(QueryLocal)

    return compatible


def is_super_matching(candidate,arr):
    canpos = True
    if (candidate[0] == '~'):
        canpos = False
        candidate = candidate[1:]
    for checker in arr:
        checkerpos = True
        if (checker[0] == '~'):
            checkerpos = False
            checker = checker[1:]
        if (checkerpos == canpos and compare_predicates(candidate, checker)):
            return False
    return True


def superRemove(query):
    if(query):

        spl_query = [q.strip() for q in query.split('|')]
        # print(spl_query)
        ans = []

        for candidate in spl_query:
            if(is_super_matching(candidate,ans)):
                ans.append(candidate)
        return ' | '.join(ans)
    return query

def makeSimple(KB):
    cnfKB = []

    for sen in KB:

        if ('=>' in sen):
            splitted = sen.split('=>')

            if ('|' in splitted[0]):
                or_splitted = splitted[0].split('|')

                for sub in or_splitted:
                    cnfKB.append(sub.strip() + ' => ' + splitted[1].strip())
            else:
                cnfKB.append(' => '.join(splitted))

        else:
            if ('&' in sen and '|' in sen):
                splithard = sen.split('|')

                for i in range(len(splithard)):
                    splithard[i] = splithard[i].split('&')

                patterns = [[]]

                for arr in splithard:
                    new_patterns = []
                    for pattern in patterns:
                        for element in arr:
                            new_patterns.append(pattern + [element])
                    patterns = new_patterns
                for pattern in patterns:
                    cnfKB.append(' | '.join(pattern))

            elif ('&' in sen):
                splittedand = sen.split('&')

                for ands in splittedand:
                    cnfKB.append(ands.strip())

            else:
                cnfKB.append(sen)
    return cnfKB

def negate(pred):
    if (pred[0] == '~'):
        return pred[1:]
    else:
        return '~' + pred

def makeImpSimple(kb):
    ans = []

    for sen in kb:
        if ('=>' in sen):
            newsen = []

            splitted = sen.split('=>')

            and_splitted = splitted[0].split('&')

            for i in range(len(and_splitted)):
                newsen.append(negate(and_splitted[i].strip()))
            newsen.append(splitted[1].strip())

            ans.append(' | '.join(newsen))
        else:
            ans.append(sen)
    return ans

def fetcharg(pred):

    if(pred[0] == '~'):
        pred = pred[1:]
    name1, args1 = re.match(pattern, pred).groups()

    # Split argument strings into individual arguments
    args1 = [arg.strip() for arg in args1.split(',')]
    return args1

def change_vars(query,var_old,var_new):
    query = query.replace("(" + var_old + ",",
                          "(" + var_new + ",")
    query = query.replace("," + var_old + ",",
                          "," + var_new + ",")
    query = query.replace("," + var_old + ")",
                          "," + var_new + ")")
    query = query.replace("(" + var_old + ")",
                          "(" + var_new + ")")
    return query

def solveQ(query, number,kbmatch):


    query1 = query
    query2 = CNF_KB[kbmatch[0]]


    query1,query2 = renameVariables(query1,query2)

    pred1 = query1.split('|')[number].strip()
    pred2 = query2.split('|')[kbmatch[1]].strip()

    argpred1 = fetcharg(pred1)
    argpred2 = fetcharg(pred2)

    uni = {}
    for i in range(len(argpred1)):
        if(argpred1[i].islower() and argpred2[i].islower()):
            uni[argpred1[i]] = argpred2[i]
            query1 = change_vars(query1, argpred1[i], argpred2[i])
            query2 = change_vars(query2, argpred1[i], argpred2[i])
        elif(argpred1[i].islower()):
            uni[argpred1[i]] = argpred2[i]
            query1 = change_vars(query1, argpred1[i], argpred2[i])
            query2 = change_vars(query2, argpred1[i], argpred2[i])
        elif (argpred2[i].islower()):
            uni[argpred2[i]] = argpred1[i]
            query1 = change_vars(query1, argpred2[i], argpred1[i])
            query2 = change_vars(query2, argpred2[i], argpred1[i])
        else:
            if(argpred1[i]!=argpred2[i]):
                return False

    pred1 = query1.split('|')[number].strip()
    pred2 = query2.split('|')[kbmatch[1]].strip()

    if(pred1 != negate(pred2)):
        return False

    query1_arr = [query.strip() for query in query1.split('|')]
    query2_arr = [query.strip() for query in query2.split('|')]

    popped1 =query1_arr.pop(number)
    # print(popped1)
    s1 = ' | '.join(query1_arr)
    popped2 = query2_arr.pop(kbmatch[1])
    # print(popped2)
    s2 = ' | '.join(query2_arr)
    # print(popped1 == negate(popped2))
    final = ''
    if(len(s1.strip()) == 0):
        final = s2

    elif(len(s2.strip()) == 0):
        final = s1
    else:
        final = s1 +' | ' +s2

    final,nan = renameVariables(final,'')

    finalUniq = " | ".join(list(set(q.strip() for q in final.split("|"))))

    finalUniqSuper = superRemove(finalUniq)

    return finalUniqSuper

import time
resolvedict = {}
def resolve(query):
    # time.sleep(0.001)
    # print('\n')
    # print('query coming: ', query)
    if (query == ''):
        return True

    if (query in resolvedict):
        # print('coming again')
        return False

    resolvedict[query] = 1

    # print('query = ',query)
    compatible = sentence_compatible(query)
    # print('possible compatible mathichngs : ',compatible)

    for next in compatible.values():
        if (len(next) == 0):
            # print('going up')
            return False

    splitted_query = [query.strip() for query in query.split('|')]
    resultlist = []
    for pp in range(len(splitted_query)):
        branches = compatible[splitted_query[pp].strip()]

        for i in reversed(range(len(branches))):
            temp = solveQ(query, pp,branches[i])
            if(temp == '' or temp):
                resultlist.append(temp)

    resultsorted = sorted(resultlist, key=len)

    # print('all possible match string results in sorted order: ',resultsorted)
    OR_BRANCHES = False
    for result in resultsorted:
        if(result == ''):
            OR_BRANCHES = True
            return True

        elif(result):
            gotresolved = resolve(result)
            OR_BRANCHES = OR_BRANCHES or gotresolved

        if(OR_BRANCHES == True):
            return True

    return OR_BRANCHES

# num = input('enter number input here: ')
num = '5'
st = time.time()
infile = open('./input.txt', 'r')

input_data = infile.read().split('\n')
Q = input_data[0]
kb_size = int(input_data[1])
KB = input_data[2: 2 + kb_size]
kb = makeSimple(KB)
CNF_KB = makeImpSimple(kb)

firstNegatedQuery = negate(Q)


try:
    outputanswer = resolve(negate(Q))

    str1 = 'TRUE'
    if(outputanswer == False):
        str1 = 'FALSE'
    if(outputanswer == True):
        str1 = 'TRUE'

    with open('output.txt', 'w') as f:
        f.write(str1)
except:
    with open('output.txt', 'w') as f:
        f.write('TRUE')
